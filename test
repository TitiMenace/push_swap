ouais c'est pour 3

A B C | A C B
C B A | C A B
B C A | B A C

(5)

abc	-> 0
acb	-> ra -> sa
bca -> rra
bac	-> sa
cba -> rra -> sa
cab -> rra


comment utiliser un singeton :

typedef struct s_data
{
	int *stack_a;
	int *stack_b;
	int	len_a;
	int len_b:
	...
};


t_data *_data()
{
	static t_data data;
	static int i = 0;
	if (i == 0)
	{
		ft_zero(data, sizeof(t_data));
		i = 1;
	}
	return (&data);
}

maintenant on peut utiliser la fonction _data() pour recuperer
un pointeur sur structure static dans le scope global:



---PREMIERE MANIERE D'UTILISER LE SINGLETON---

int main(void)
{
	t_data *data;

	data = _data();
	data->len_a++;
}

---DEUXIEME MANIERE (DE FRAUDEUR)---

int main(void)
{
	_data()->len_a++;
}

---VOILA ON A RECREE UNE GLOBALE YOUHUHUHOU---




COMMENT FAIRE PS

=======PARSING========

1) faire une structure data en singleton avec les deux stacks en int * et leur
longueur respective on aura aussi besoin d'une stack c avec len_c (2min)

2) faire le parsing et stocker les arguments dans la stack_a. (1h)

3) coder les sous-mouvements (1h)
	-stack_add_front();
	-stack_del_front();
	-stack_add_back();
	-stack_del_back();

	Pour ca tu peux au choix:
	- remalloc de size + 1 ou size - 1 a chaque sous mouvement -> pb on fait un peu trop de mallocs
	- malloc de size * 2 pour chaque stack -> pb on utilise 2* trop d'espace a chaque fois
	- (technique de giga chad) malloc de size + 3 ou 4 et ne pas remalloc a chaque fois, c'est un hybride, c'est style mais c'est chiant a faire

	pour tout ca on aura besoin d'utiliser et reactualiser les _data()->len_x

4) coder les mouvements avec les sous mouvements (10min)

=======ALGO=======

1) on copie la stack a dans la stack c;

2) on fait un sort_int_tab(_data->stack_c); Avec ca on pourra obtenir la mediane de a qui sera tout simplenent: mediane =  stack_c[len_c / 2]

3) on fait des ra sur tous les elements de stack_a et des pb sur chaque nombre en haut de a qui est inferieur a une mediane.


CHECK DE PUSH SWAP;

-rotate clear !
-reverse rotate ?

